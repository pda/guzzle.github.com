===================
HTTP client for PHP
===================

.. highlight:: php

Guzzle gives PHP developers complete control over HTTP requests while utilizing HTTP/1.1 best practices.  Guzzle's HTTP functionality is a robust framework built on top of the `PHP libcurl bindings <http://www.php.net/curl>`_.

Quick overview of Guzzle's HTTP features
----------------------------------------

* Supports GET, HEAD, POST, DELETE, OPTIONS, PUT, and TRACE methods
* `Persistent connections <http://en.wikipedia.org/wiki/Persistent_connections>`_ are implicitly managed by Guzzle, resulting in huge performance benefits
* Send requests in parallel
* Allows custom entity bodies to be sent in PUT and POST requests, including sending data from a PHP stream
* Allows full access to request HTTP headers
* Responses can be cached and served from cache using the CachePlugin
* Failed requests can be retried using truncated `exponential backoff <http://en.wikipedia.org/wiki/Exponential_backoff>`_ using the ExponentialBackoffPlugin
* All data sent over the wire can be logged using the LogPlugin
* Cookie sessions can be maintained between requests using the CookiePlugin
* Supports HTTPS and SSL certificate validation
* Requests can be sent through a proxy
* Automatically requests compressed data and automatically decompresses data
* Supports authentication methods provided by cURL (Basic, Digest, GSS Negotiate, NTLM)
* Transparently follows redirects
* Subject/Observer signal slot system for modifying request behavior

Using a Client object
---------------------

Requests can be created by using methods of the ``Guzzle\Http\Client`` object.  When instantiating a client object, you must pass a "base URL" and optionally pass configuration options.  A base URL is the full URL of the server you are connecting to, and it can include query string parameters and a base path.  If you include ``{{ key }}`` in your base URL, then configuration options will be taken from the configuration options of the client and injected into the URL.

In the following example, we are interacting with the Unfuddle API and issuing a GET request to retrieve a listing of tickets in the 123 project::

    <?php

    use Guzzle\Http\Client;

    $client = new Client('https://mydomain.unfuddle.com/api/v1');
    $request = $client->get('projects/123/tickets');
    $request->setAuth('myusername', 'mypassword');
    $response = $request->send();

Notice that the URI provided to the client's ``get`` method is relative.  The path in the URI is also relative.  Relative paths will add to the path of the base URL of the client-- so in the example above, the path of the base URL is ``/api/v1``, the relative path is ``projects/123/tickets``, and the URL will ultimately become ``https://mydomain.unfuddle.com/api/v1/projects/123/tickets``.  If a relative path and a query string are provided, then the relative path will be appended to the base URL path, and the query string provided will be merged into the query string of the base URL.  If an absolute path is provided (e.g. ``/path/to/something``), then the path specified in the base URL of the client will be replaced with the absolute path, and the query string provided will replace the query string of the base URL.  If an absolute URL is provided (e.g. ``http://www.test.com/path``), then the request will completely use the absolute URL as-is without merging in any of the URL parts specified in the base URL.

All requests in the above client would need `basic HTTP authorization <http://www.ietf.org/rfc/rfc2617.txt>`_ added after they are created.  You can automate this and add the authorization header to all requests generated by the client by adding a :ref:`BasicAuthPlugin <basic-auth>` to the client's event dispatcher.

Sending requests and using responses
------------------------------------

Requests
~~~~~~~~

Requests can be created from a client using method names that match the HTTP verb:

.. code-block:: php

    <?php

    use Guzzle\Http\Client;

    $client = new Client('http://baseurl.com/api/v{{version}}', array(
        'version' => 1
    ));

    // Relative to base URL (http://baseurl.com/api/v1/path?query=123&value=abc)
    $request = $client->get('path?query=123&value=abc');

    // Overrides base URL's path (http://baseurl.com/path?query=123&value=abc)
    $request = $client->head('/path?query=123&value=abc');

    // Delete using an Absolute URL
    $request = $client->delete('http://www.example.com/path?query=123&value=abc');

    // Send a PUT request using the contents of a PHP stream as the body
    // Send using an absolute URL (overrides the base URL)
    $response = $client->put('http://www.example.com/upload', array(
        'X-Header' => 'My Header'
    ), fopen('http://www.test.com/', 'r'));

    // Create a POST request and add the POST files manually
    $request = $client->post('http://localhost:8983/solr/update')
        ->addPostFiles(array(
            'file' => '/path/to/documents.xml'
        ));

    // Create a request by method
    $request = $client->createRequest('TRACE');

    // Check if a resource supports the DELETE method
    $supportsDelete = $client->options('/path')->send()->isMethodAllowed('delete');

If you know exactly what HTTP message you want to send, you can create request objects from messages::

    <?php

    use Guzzle\Http\Message\RequestFactory;

    $request = RequestFactory::fromMessage(
        "PUT / HTTP/1.1\r\n" .
        "Host: test.com:8081\r\n" .
        "Content-Type: text/plain"
        "Transfer-Encoding: chunked\r\n" .
        "\r\n" .
        "this is the body"
    );

Request objects are all about building an HTTP message.  Each part of an HTTP request message can be set individually using methods on the request object or set in bulk using the setUrl() method.  Here's the format of an HTTP request with each part of the request referencing the method used to change it::

    PUT(a) /path(b)?query=123(c) HTTP/1.1(d)
    X-Header(e): header
    Content-Length(e): 4

    data(f)

+-------------------------+---------------------------------------------------------------------------------+
| a. **Method**           | The request method can only be set when instantiating a request                 |
+-------------------------+---------------------------------------------------------------------------------+
| b. **Path**             | ``$request->setPath('/path');``                                                 |
+-------------------------+---------------------------------------------------------------------------------+
| c. **Query**            |``$request->getQuery()->set('query', '123'); // see ``Guzzle\Http\QueryString``  |
+-------------------------+---------------------------------------------------------------------------------+
| d. **Protocol version** | ``$request->setProtocolVersion('1.1');``                                        |
+-------------------------+---------------------------------------------------------------------------------+
| e. **Header**           | ``$request->setHeader('X-Header', 'header');``                                  |
+-------------------------+---------------------------------------------------------------------------------+
| f. **Entity Body**      |  ``$request->setBody('data'); // Only available with PUT and POST requests``    |
+-------------------------+---------------------------------------------------------------------------------+

PUT
^^^

Here's how to send a PUT request (substitute ``post`` for ``put`` to send a custom POST request)::

    <?php

    // Create a new PUT request, setting headers and an entity body
    $request = $client->put('http://www.example.com/upload', array(
        'X-Guzzle-Test-Header' => 'header_value'
    ), 'this is the body');

    $response = $request->send();

POST
^^^^

Guzzle helps to make it extremely easy to send POST requests.  POST requests will be sent with an ``application/x-www-form-urlencoded`` Content-Type header if no files are being sent in the POST.  If files are specified in the POST, then the Content-Type header will become ``multipart/form-data``.  Here's how to create a multipart/form-data POST request containing files and fields::

    <?php

    $request = $client->post('http://www.example.com/upload')
        ->addPostFields(array(
            'custom_key' => 'value'
        ))->addPostFiles(array(
            'file' => '/path/to/file.xml'
        ));

This can be achieved more succinctly-- ``Client::post()`` accepts three arguments: the URL, optional headers, and the post fields.  To send files in the POST request, prepend the ``@`` symbol to the array value (just like you would if you were using the PHP ``curl_setopt`` function)::

    <?php

    $request = $client->post('http://www.example.com/upload', null, array(
        'custom_field' => 'my custom value',
        'file' => '@/path/to/file.xml'
    ));

**Always** sanitize user supplied data when sending POST requests::

    <?php

    // Prevent users from accessing sensitive files by sanitizing input
    $_POST = array('firstname' => '@/etc/passwd');
    $request = $client->post('http://www.example.com', null, array (
        'firstname' => str_replace('@', '', $_POST['firstname'])
    ));

Dealing with errors
~~~~~~~~~~~~~~~~~~~

Exceptions
^^^^^^^^^^

Requests that receive a 4xx or 5xx response will throw a ``Guzzle\Http\Message\BadResponseException``.  Here's an example of catching a BadResponseException::

    <?php

    try {
        $response = $client->get('/not_found.xml')->send();
    } catch (BadResponseException $e) {
        echo 'Uh oh! ' . $e->getMessage();
    }

Throwing an exception when a 4xx or 5xx response is encountered is the default behavior of Guzzle requests.  This behavior can be overridden by adding an event listener with a higher priority than -255 that stops event propagation.  You can subscribe to ``request.error`` to receive notifications any time an unsuccessful response is received.

You can change the response that will be associated with the request by calling ``setResponse()`` on the ``$event['request']`` object passed into your listener, or by changing the ``$event['response']`` value of the ``Guzzle\Common\Event`` object that is passed to your listener.  Transparently changing the response associated with a request in this manner would allow you to retry failed requests without complicating the code that uses the client.  This might be useful for sending requests to a web service that has expiring auth tokens.  When a response shows that your token has expired, you can get a new token, retry the request with the new token, and return the successful response to the user.

Here's an example of retrying a request using updated authorization credentials when a 401 response is received, overriding the response of the original request with the new response, and still allowing the default exception behavior to be called when other non-200 response status codes are encountered::

    <?php

    // Add custom error handling to any request created by this client
    $client->getEventDispatcher()->addListener('request.error', function(Event $event) {

        if ($event['response']->getStatusCode() == 401) {

            $newRequest = $event['request']->clone();
            $newRequest->setHeader('X-Auth-Header', MyApplication::getNewAuthToken());
            $newResponse = $newRequest->send();

            // Set the response object of the request without firing more events
            $event['response'] = $newResponse;

            // You can also change the response and fire the normal chain of
            // events by calling $event['request']->setResponse($newResponse);

            // Stop other events from firing when you override 401 responses
            $event->stopPropagation();
        }

    });

cURL errors
^^^^^^^^^^^

Connection problems and cURL specific errors can also occur when transferring requests using Guzzle.  When Guzzle encounters cURL specific errors while transferring a single request, a ``Guzzle\Http\Curl\CurlException`` is thrown with an informative error message and access to the cURL error message.  Sending a request that cannot resolve a host name will result in a CurlException with an exception message similar to the following:

.. code-block:: none

    [curl] 6: Couldn't resolve host 'www.nonexistenthost.com' [url] http://www.nonexistenthost.com/ [info] array (
      'url' => 'http://www.nonexistenthost.com/',
      'content_type' => NULL,
      'http_code' => 0,
      'header_size' => 0,
      'request_size' => 0,
      'filetime' => -1,
      'ssl_verify_result' => 0,
      'redirect_count' => 0,
      'total_time' => 0,
      'namelookup_time' => 0,
      'connect_time' => 0,
      'pretransfer_time' => 0,
      'size_upload' => 0,
      'size_download' => 0,
      'speed_download' => 0,
      'speed_upload' => 0,
      'download_content_length' => -1,
      'upload_content_length' => -1,
      'starttransfer_time' => 0,
      'redirect_time' => 0,
      'certinfo' =>
      array (
      ),
    ) [debug] * getaddrinfo(3) failed for www.nonexistenthost.com:80
    * Couldn't resolve host 'www.nonexistenthost.com'
    * Closing connection #0

A ``Guzzle\Common\ExceptionCollection`` exception is thrown when a cURL specific error occurs while transferring multiple requests in parallel.  You can then iterate over all of the exceptions encountered during the transfer.

Entity Bodies
~~~~~~~~~~~~~

`Entity body <http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html>`_ is the term used for the body of an HTTP message.  The entity body of requests and responses is inherently a `PHP stream <http://php.net/manual/en/book.stream.php>`_ in Guzzle.  The body of the request can be either a string or a PHP stream which are converted into a ``Guzzle\Http\EntityBody`` object using its factory method.  When using a string, the entity body is stored in a `temp PHP stream <http://www.php.net/manual/en/wrappers.php.php>`_.  The use of temp PHP streams helps to protect your application from running out of memory when sending or receiving large entity bodies in your messages.  When more than 2MB of data is stored in a temp stream, it automatically stores the data on disk rather than in memory.

EntityBody objects provide a great deal of functionality: compression, decompression, calculate the Content-MD5, calculate the Content-Length (when the resource is repeatable), guessing the Content-Type, and more.  Guzzle doesn't need to load an entire entity body into a string when sending or retrieving data; entity bodies are streamed when being uploaded and downloaded.

Here's an example of gzip compressing a text file then sending the file to a URL::

    <?php

    use Guzzle\Http\EntityBody;

    $body = EntityBody::factory(fopen('/path/to/file.txt', 'r'));
    $body->compress();
    $response = $client->put('http://localhost:8080/uploads', null, $body)->send();

The body of the request can be specified in the ``Client::put()`` or ``Client::post()``  method, or, you can specify the body of the request by calling the ``setBody()`` method of any ``Guzzle\Http\Message\EntityEnclosingRequestInterface`` object.  If you need the response entity body of a request to use a destination other than a temporary stream (e.g. FTP, HTTP, a specific file, an open stream), you can set the entity body object that will be used to hold the response body by calling ``setResponseBody()`` on any request object.

Responses
~~~~~~~~~

Sending a request will return a ``Guzzle\Http\Message\Response`` object.  You can view the HTTP response message by casting the Response object to a string.  Casting the response to a string will return the entity body of the response as a string too, so this might be an expensive operation if the entity body is stored in a file or network stream.  If you only want to see the response headers, you can call ``getRawHeaders()``.

The Response object contains helper methods for retrieving common response headers.  These helper methods normalize the variations of HTTP response headers so that you will not need to check for the upper-case existence, lowercase existence, or if you aren't sure if the header will contain a hyphen::

    <?php

    $response->getContentMd5();
    $response->getEtag();
    $response->getCacheControl();
    $response->getHeader('Content-Length');

The entity body of a response can be retrieved by calling ``$response->getBody()``.  Pass TRUE to this method to retrieve the body as a string rather than an EntityBody object;  this is a convenience feature-- an EntityBody can be cast as a string.

Send HTTP requests in parallel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sending many HTTP requests serially (one at a time) can cause an unnecessary delay in a script's execution. Each request must complete before a subsequent request can be sent. By sending requests in parallel, a pool of HTTP requests can complete at the speed of the slowest request in the pool, significantly reducing the amount of time needed to execute multiple HTTP requests. Guzzle provides a wrapper for the curl_multi functions in PHP.

You can pass a single request or an array of requests to a client's ``send()`` method.  Here's an example of sending three requests in parallel using a client object::

    <?php

    use Guzzle\Common\ExceptionCollection;

    try {
        $responses = $client->send(array(
            $client->get('http://www.google.com/'),
            $client->head('http://www.google.com/'),
            $client->get('https://www.github.com/')
        ));
    } catch (ExceptionCollection $e) {
        echo "The following exceptions were encountered:\n";
        foreach ($e as $exception) {
            echo $exception->getMessage() . "\n";
        }
    }

A single request failure will not cause the entire pool of requests to fail.  Any exceptions thrown while transferring a pool of requests will be aggregated into a ``Guzzle\Common\ExceptionCollection`` exception.

Managed persistent HTTP connections
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Persistent HTTP connections are an extremely important aspect of the HTTP/1.1 protocol that is often overlooked by PHP HTTP clients. Persistent connections allows data to be transferred between a client and server without the need to reconnect each time a subsequent request is sent, providing a significant performance boost to applications that need to send many HTTP requests to the same host.  Guzzle implicitly manages persistent connections for all requests.

All HTTP requests sent through Guzzle are sent using the same cURL multi handle.  cURL will maintain a cache of persistent connections on a multi handle.  As long as you do not override the default ``Guzzle\Http\Curl\CurlMulti`` object in your clients, you will benefit from application-wide persistent connections.  More information about cURL's internal design and persistent connection handling can be found at http://curl.haxx.se/dev/internals.html.

Low level cURL access
~~~~~~~~~~~~~~~~~~~~~

Most of the functionality implemented in the libcurl bindings has been simplified and abstracted by Guzzle. Developers who need access to `cURL specific functionality <http://www.php.net/curl_setopt>`_ that is not abstracted by Guzzle (e.g. proxies and SSL) can still add cURL handle specific behavior to Guzzle HTTP requests using something like this::

    <?php

    $request->getCurlOptions()->set(CURLOPT_SSL_VERIFYHOST, true);

You can add cURL options to every request sent from your client by adding configuration options to the client that are prefixed with "curl.".  Clients will automatically map cURL constants for keys and values to their correct PHP value.

.. code-block:: php

    <?php

    $client = new Guzzle\Http\Client('https://example.com/', array(
        'curl.CURLOPT_SSL_VERIFYHOST' => false,
        'curl.CURLOPT_SSL_VERIFYPEER' => false,
        'curl.CURLOPT_PROXY'          => 'proxy.mydomain.com:8080',
        'curl.CURLOPT_PROXYTYPE'      => 'CURLPROXY_HTTP'
    ));

URI templates
-------------

Guzzle supports the entire `URI templates RFC <http://tools.ietf.org/html/draft-gregorio-uritemplate-08>`_.  URI templates add a special syntax to URIs that replace template place holders with user defined variables.

Every request created by a Guzzle HTTP client passes through a URI template so that URI template expressions are automatically expanded::

    <?php

    $client = new Guzzle\Http\Client('https://example.com/', array(
        'a' => 'hi'
    ));

    $request = $client->get('/{a}');

Because of URI template expansion, the URL of the above request will become ``https://example.com/hi``.  Notice that the template was expanded using configuration variables of the client.  You can pass in custom URI template variables by passing the URI of your request as an array where the first index of the array is the URI template and the second index of the array are template variables that are merged into the client's configuration variables::

    $request = $client->get(array('/test{?a,b}', array(
        'b' => 'there'
    ));

The URL for this request will become ``https://test.com?a=hi&b=there``.  URI templates aren't limited to just simple variable replacements;  URI templates can provide an enormous amount of flexibility when creating request URIs::

    <?php

    $request = $client->get(array('http://example.com{+path}{/segments}{?query,data*}', array(
        'path'     => '/foo/bar',
        'segments' => array('one', 'two'),
        'query'    => 'test',
        'data'     => array(
            'more' => 'value'
        )
    )));

The resulting URL would become ``http://example.com/foo/bar/one/two?query=test&more=value``.

By default, URI template expressions are enclosed in an opening and closing brace (e.g. ``{var}``).  If you are working with a web service that actually uses braces (e.g. Solr), then you can specify a custom regular expression to use to match URI template expressions::

    <?php

    $client->getUriTemplate()->setRegex('/\<\$(.+)\>/');
    $client->get('/<$a>');

You can learn about all of the different features of URI templates by reading the `URI template RFC <http://tools.ietf.org/html/draft-gregorio-uritemplate-08>`_.

Plugins for common HTTP request behavior
----------------------------------------

Guzzle provides easy to use request plugins that add behavior to requests based on signal slot event notifications.

.. note::

    Any event subscriber attached to the ``EventDispatcher`` of a ``Client`` object will automatically be attached to all request objects created by the client.  This allows you to attach, for example, a  HistoryPlugin to a client object, and from that point on, every request sent through that client will utilize the HistoryPlugin.

Over the wire logging
~~~~~~~~~~~~~~~~~~~~~

Use the ``Guzzle\Http\Plugin\LogPlugin`` to view all data sent over the wire, including entity bodies and redirects::

    <?php

    use Guzzle\Common\Log\ZendLogAdapter;
    use Guzzle\Http\Plugin\LogPlugin;

    $adapter = new ZendLogAdapter(new \Zend_Log(new \Zend_Log_Writer_Stream('php://output')));
    $logPlugin = new LogPlugin($adapter, LogPlugin::LOG_VERBOSE);

    // Attach the plugin to the request, which will in turn be attached to all
    // requests generated by the client
    $client->getEventDispatcher()->addSubscriber($logPlugin);

    $response = $client->get('http://google.com')->send();

The code sample above wraps a ``Zend_Log`` object using a ``Guzzle\Common\Log\ZendLogAdapter``.  After attaching the request to the plugin, all data sent over the wire will be logged to stdout.  The above code sample would output something like:

.. code-block:: none

    2011-03-10T20:07:56-06:00 DEBUG (7): www.google.com - "GET / HTTP/1.1" - 200 0 - 0.195698 0 45887
    * About to connect() to google.com port 80 (#0)
    *   Trying 74.125.227.50... * connected
    * Connected to google.com (74.125.227.50) port 80 (#0)
    > GET / HTTP/1.1
    Accept: */*
    Accept-Encoding: deflate, gzip
    User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)
    Host: google.com

    < HTTP/1.1 301 Moved Permanently
    < Location: http://www.google.com/
    < Content-Type: text/html; charset=UTF-8
    < Date: Fri, 11 Mar 2011 02:06:32 GMT
    < Expires: Sun, 10 Apr 2011 02:06:32 GMT
    < Cache-Control: public, max-age=2592000
    < Server: gws
    < Content-Length: 219
    < X-XSS-Protection: 1; mode=block
    <
    * Ignoring the response-body
    * Connection #0 to host google.com left intact
    * Issue another request to this URL: 'http://www.google.com/'
    * About to connect() to www.google.com port 80 (#1)
    *   Trying 74.125.45.147... * connected
    * Connected to www.google.com (74.125.45.147) port 80 (#1)
    > GET / HTTP/1.1
    Host: www.google.com
    Accept: */*
    Accept-Encoding: deflate, gzip
    User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)

    < HTTP/1.1 200 OK
    < Date: Fri, 11 Mar 2011 02:06:32 GMT
    < Expires: -1
    < Cache-Control: private, max-age=0
    < Content-Type: text/html; charset=ISO-8859-1
    < Set-Cookie: PREF=ID=8a61470bce22ed5b:FF=0:TM=1299809192:LM=1299809192:S=axQwBxLyhXV7mbE3; expires=Sun, 10-Mar-2013 02:06:32 GMT; path=/; domain=.google.com
    < Set-Cookie: NID=44=qxXLtXgSKI2S9_mG7KbN7yR2atSje1B9Eft_CHTyjTuIivwE9kB1sATn_YPmBNhZHiNyxcP4_tIYnawjSNWeAepixK3CoKHw-RINrgGNSG3RfpAG7M-IKxHmLhJM6NeA; expires=Sat, 10-Sep-2011 02:06:32 GMT; path=/; domain=.google.com; HttpOnly
    < Server: gws
    < X-XSS-Protection: 1; mode=block
    < Transfer-Encoding: chunked
    <
    * Connection #1 to host www.google.com left intact
    <!doctype html><html><head>
    [...snipped]

Truncated exponential backoff
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``Guzzle\Http\Plugin\ExponentialBackoffPlugin`` automatically retries failed HTTP requests using truncated exponential backoff::

    <?php

    use Guzzle\Http\Plugin\ExponentialBackoffPlugin;

    $client->getEventDispatcher()->addSubscriber(new ExponentialBackoffPlugin());
    $request = $client->get('http://google.com/');
    $request->send();

.. note::

    By default, the ExponentialBackoffPlugin will retry all 500 and 503 responses up to 3 times.  The number of retries and the HTTP status codes that are retried can be configured in the constructor of the plugin.

PHP-based caching forward proxy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Guzzle can leverage HTTP's caching specifications using the ``Guzzle\Http\Plugin\CachePlugin``.  The CachePlugin provides a private transparent proxy cache that caches HTTP responses.  The caching logic, based on `RFC 2616 <http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html>`_, uses HTTP headers to control caching behavior, cache lifetime, and supports ETag and Last-Modified based revalidation::

    <?php

    use Doctrine\Common\Cache\ArrayCache;
    use Guzzle\Common\Cache\DoctrineCacheAdapter;
    use Guzzle\Http\Plugin\CachePlugin;

    $adapter = new DoctrineCacheAdapter(new ArrayCache());
    $cache = new CachePlugin($adapter, true);
    $client->getEventDispatcher()->addSubscriber($cache);

    $request = $client->get('http://www.wikipedia.org/');
    $request->send();

    // The next request will revalidate against the origin server to see if it
    // has been modified.  If a 304 response is recieved the response will be
    // served from cache
    $request->send();

Guzzle doesn't try to reinvent the wheel when it comes to caching or logging.  Plenty of other frameworks have excellent solutions in place that you are probably already using in your applications.  Guzzle uses adapters for caching and logging.  Guzzle currently supports log adapters for the Zend Framework 1.0/2.0 and Monolog, and cache adapters for `Doctrine 2.0 <http://www.doctrine-project.org/>`_ and the Zend Framework 1.0/2.0.

See :doc:`Caching </guide/http/caching>` for more information on the caching plugin.

Cookie session plugin
~~~~~~~~~~~~~~~~~~~~~

Some web services require a Cookie in order to maintain a session.  The ``Guzzle\Http\Plugin\CookiePlugin`` will add cookies to requests and parse cookies from responses using a CookieJar object::

    <?php

    use Guzzle\Http\Plugin\CookiePlugin;
    use Guzzle\Http\CookieJar\ArrayCookieJar;

    $plugin = new CookiePlugin(new ArrayCookieJar());
    $client->getEventDispatcher()->addSubscriber($plugin);
    $request = $client->get('http://www.yahoo.com/');

    // Send the request with no cookies and parse the returned cookies
    $request->send();

    // Send the request again, noticing that cookies are being sent
    $request->send();

    echo $request;

MD5 hash validator plugin
~~~~~~~~~~~~~~~~~~~~~~~~~

Entity bodies can sometimes be modified over the wire due to a faulty TCP transport or misbehaving proxy.  If an HTTP response contains a Content-MD5 header, then a MD5 hash of the entity body of a response can be compared against the Content-MD5 header of the response to determine if the response was delivered intact.  The ``Guzzle\Http\Plugin\Md5ValidatorPlugin`` will throw an ``UnexpectedValueException`` if the calculated MD5 hash does not match the Content-MD5 hash::

    <?php

    use Guzzle\Http\Plugin\Md5ValidatorPlugin;

    $plugin = new Md5ValidatorPlugin();
    $client->getEventDispatcher()->addSubscriber($plugin);
    $request = $client->get('http://www.yahoo.com/');
    $request->send();

Calculating the MD5 hash of a large entity body or an entity body that was transferred using a Content-Encoding is an expensive operation.  When working in high performance applications, you might consider skipping the MD5 hash validation for entity bodies bigger than a certain size or Content-Encoded entity bodies (see ``Guzzle\Http\Plugin\Md5ValidatorPlugin`` for more information).

History plugin
~~~~~~~~~~~~~~

The history plugin tracks all of the requests and responses sent through a request or client.  This plugin can be useful for crawling or unit testing.  By default, the history plugin stores up to 10 requests and responses.

.. code-block:: php

    <?php

    use Guzzle\Http\Plugin\HistoryPlugin;

    $history = new HistoryPlugin();
    $history->setLimit(5);

    $client->getEventDispatcher()->addSubscriber($history);
    $client->get('http://www.yahoo.com/')->send();

    echo $history->getLastRequest();
    echo $history->getLastResponse();
    echo count($history);

Mock Plugin
~~~~~~~~~~~

The mock plugin is useful for testing Guzzle clients.  The mock plugin allows you to queue an array of responses that will satisfy requests sent from a client by consuming the request queue in FIFO order.

.. code-block:: php

    <?php

    use Guzzle\Http\Plugin\MockPlugin;
    use Guzzle\Http\Message\Response;

    $mock = new MockPlugin();
    $mock->addResponse(new Response(200))
         ->addResponse(new Response(404));

    $client->getEventDispatcher()->addSubscriber($mock);

    // The following request will receive a 200 response from the plugin
    $client->get('http://www.example.com/')->send();

    // The following request will receive a 404 response from the plugin
    $client->get('http://www.test.com/')->send();

.. _basic-auth:

Basic Auth Plugin
~~~~~~~~~~~~~~~~~

If your web service client requires basic authorization, then you can use the BasicAuthPlugin to easily add an Authorization header to each request sent by the client.

.. code-block:: php

    <?php

    use Guzzle\Http\Plugin\BasicAuthPlugin;
    $client->getEventDispatcher()->addSubscriber(new BasicAuthPlugin('username', 'password'));
    $response = $client->get('projects/1/people')->send();
    $xml = new SimpleXMLElement($response->getBody(true));
    foreach ($xml->person as $person) {
        echo $person->email . "\n";
    }

Batch Queue Plugin
~~~~~~~~~~~~~~~~~~

Send a large number of requests using the batch queue plugin.  Any request created by a client will automatically be tracked and queued by the BatchQueuePlugin. In the constructor of the plugin, you can specify the maximum amount of requests to keep in queue before implicitly flushing, or set 0 to never automatically flush.

.. code-block:: php

    <?php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\BatchQueuePlugin;

    $client = new Client('http://www.test.com/');

    // Here we are saying that if 10 or more requests are in the batch queue,
    // then it must automatically flush the queue and send the requests.
    $batchPlugin = new BatchQueuePlugin(10);

    // Add the batch plugin to the client object
    $client->getEventDispatcher()->addSubscriber($batchPlugin);

    // Queue up some requests on the BatchQueuePlugin
    $request1 = $client->get('/');
    $request2 = $client->get('/');
    $request3 = $client->get('/');

    // If the batch plugin is handy, you can call the flush method directly
    $batchPlugin->flush();

    // If you no longer have the batch plugin handy, you can emit the 'flush' event
    // from the client
    $client->dispatch('flush');

OAuth 1.0 Plugin
~~~~~~~~~~~~~~~~

Guzzle ships with an OAuth 1.0 plugin that can sign requests using a consumer key, consumer secret, OAuth token, and OAuth secret.  Here's an example showing how to send an authenticated request to the Twitter REST API:

.. code-block:: php

    <?php

    $client = new Guzzle\Http\Client('http://api.twitter.com/1');
    $oauth = new Guzzle\Http\Plugin\OauthPlugin(array(
        'consumer_key'    => 'my_key',
        'consumer_secret' => 'my_secret',
        'token'           => 'my_token',
        'token_secret'    => 'my_token_secret'
    ));
    $client->getEventDispatcher()->addSubscriber($oauth);

    $response = $client->get('statuses/public_timeline.json')->send();

If you need to use a custom signing method, you can pass a ``signature_method`` configuration option in the constructor of the OAuth plugin.  The ``signature_method`` option must be a callable variable that accepts a string to sign and signing key and returns a signed string.

Third-party plugins
~~~~~~~~~~~~~~~~~~~

* `WSSE Authentication plugin <https://github.com/davedevelopment/guzzle-wsse-auth-plugin>`_
